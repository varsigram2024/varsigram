class PostListCreateFirestoreView(APIView):
    """
    Create a new post or list all posts from Firestore.
    """
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    authentication_classes = [JWTAuthentication]

    def get(self, request):
        try:
            # --- Pagination setup ---
            page_size = int(request.query_params.get("page_size", 10))
            start_after_id = request.query_params.get("start_after", None)

            posts_ref = db.collection('posts').order_by('timestamp', direction=firestore.Query.DESCENDING)

            if start_after_id:
                start_doc = db.collection('posts').document(start_after_id).get()
                if start_doc.exists:
                    posts_ref = posts_ref.start_after(start_doc)
                else:
                    return Response({"error": "Invalid start_after ID"}, status=status.HTTP_400_BAD_REQUEST)

            docs = posts_ref.limit(page_size).stream()
            
            posts_list = []
            author_ids = set()
            last_doc_id = None

            for doc in docs:
                post_data = doc.to_dict()
                post_data['id'] = doc.id
                posts_list.append(post_data)
                last_doc_id = doc.id  # Will end up being the last doc in the loop
                if 'author_id' in post_data:
                    author_ids.add(str(post_data['author_id']))

            # --- Hydrate authors ---
            authors_map = {}
            if author_ids:
                authors_from_postgres = User.objects.filter(id__in=author_ids).only('id', 'email', 'profile_pic_url', 'is_verified')
                for author in authors_from_postgres:
                    author_name = None
                    display_name_slug = None
                    if hasattr(author, 'student'):
                        author_name = author.student.name
                        display_name_slug = getattr(author.student, 'display_name_slug', None)
                    elif hasattr(author, 'organization'):
                        author_name = author.organization.organization_name
                        display_name_slug = getattr(author.organization, 'display_name_slug', None)
                        exclusive = getattr(author.organization, 'exclusive', False)

                    authors_map[str(author.id)] = {
                        "id": author.id,
                        "email": author.email,
                        "profile_pic_url": author.profile_pic_url,
                        "name": author_name,
                        "display_name_slug": display_name_slug,
                        "is_verified": author.is_verified,
                        "exclusive": exclusive if hasattr(author, 'organization') else False
                    }

            # --- Has liked logic ---
            if request.user.is_authenticated and posts_list:
                user_id = str(request.user.id)
                for post in posts_list:
                    like_doc_ref = db.collection('posts').document(post['id']).collection('likes').document(user_id)
                    post['has_liked'] = like_doc_ref.get().exists

            serializer = FirestorePostOutputSerializer(posts_list, many=True, context={'authors_map': authors_map})
            return Response({
                "results": serializer.data,
                "next_cursor": last_doc_id if len(posts_list) == page_size else None
            }, status=status.HTTP_200_OK)

        except Exception as e:
            return Response({"error": f"Failed to retrieve posts: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)